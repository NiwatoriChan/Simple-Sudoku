<!DOCTYPE html>
<html lang="fr" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Game (Vue.js)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" xintegrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; 
        }
        :root { 
            font-family: 'Inter', system-ui, Avenir, Helvetica, Arial, sans-serif; 
            --board-bg-color-default: #0d1117; 
        }

        .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }

        #toolbar { 
            border-radius: 0.5rem; 
        }
        .tool-button {
            transition: background-color 0.2s ease-in-out, transform 0.1s ease, color 0.2s ease-in-out;
            display: inline-flex; align-items: center; justify-content: center;
            height: 2.25rem; /* Base height for mobile */
            padding-left: 0.5rem; /* Base padding for mobile */
            padding-right: 0.5rem; /* Base padding for mobile */
            border-radius: 0.375rem; /* rounded-md */
            font-weight: 500; /* medium */
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .tool-button {
                height: 2.5rem; /* sm:h-10 */
                padding-left: 1rem; /* sm:px-4 */
                padding-right: 1rem;
            }
        }

        .tool-button.icon-only { 
            width: 2.25rem; /* Base width for mobile */
            padding-left: 0.5rem; /* Adjust if needed */
            padding-right: 0.5rem; /* Adjust if needed */
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .tool-button.icon-only {
                width: 2.5rem; /* sm:w-10 */
                padding-left: 0.75rem; /* sm:p-2.5 if icon only */
                padding-right: 0.75rem;
            }
        }
        .tool-button:active { transform: scale(0.95); }

        .modal-backdrop { background-color: rgba(0, 0, 0, 0.7); } 
        .modal-content { 
            transform: scale(0.95); opacity: 0; animation: modal-appear 0.3s forwards; 
            background-color: #161b22; /* A slightly lighter dark shade for modal */
            border: 1px solid rgba(255,255,255,0.1); /* Subtle border */
            box-shadow: 0 10px 25px rgba(0,0,0,0.3), 0 20px 40px rgba(0,0,0,0.2); /* Enhanced shadow */
        }
        @keyframes modal-appear { to { opacity: 1; transform: scale(1); } }

        /* Sudoku Grid Borders - ensuring they are crisp */
        #sudoku-grid .sudoku-cell {
            transition: background-color 0.15s ease-in-out;
        }
        /* Major grid lines (between 3x3 blocks) */
        #sudoku-grid .sudoku-cell:nth-child(3n):not(:last-child) { border-right-width: 2px; } 
        #sudoku-grid > div:nth-child(3n):not(:last-child) .sudoku-cell { border-bottom-width: 2px; }
        /* Explicitly target the 3rd and 6th rows of cells for bottom border */
        #sudoku-grid > div:nth-child(3) .sudoku-cell,
        #sudoku-grid > div:nth-child(6) .sudoku-cell { border-bottom-width: 2px; }
        
        @media (min-width: 640px) { /* sm breakpoint - thicker borders for larger screens */
            #sudoku-grid .sudoku-cell:nth-child(3n):not(:last-child) { border-right-width: 3px; }
            #sudoku-grid > div:nth-child(3n):not(:last-child) .sudoku-cell { border-bottom-width: 3px; }
            #sudoku-grid > div:nth-child(3) .sudoku-cell,
            #sudoku-grid > div:nth-child(6) .sudoku-cell { border-bottom-width: 3px; }
        }

        /* Ensure the last column and row don't have the thick border from 3n */
        #sudoku-grid .sudoku-cell:nth-child(9) { border-right-width: 1px; } /* Reset to default border */
        #sudoku-grid > div:nth-child(9) .sudoku-cell { border-bottom-width: 1px; } /* Reset to default border */


        .submenu-item {
            display: block;
            padding: 0.5rem 1rem; /* p-2 px-4 */
            font-size: 0.875rem; /* text-sm */
            color: #d1d5db; /* text-gray-300 */
            cursor: pointer;
            transition: background-color 0.15s ease, color 0.15s ease;
        }
        .submenu-item:hover {
            background-color: #374151; /* hover:bg-gray-700 */
            color: #ffffff; /* hover:text-white */
        }

        [v-cloak] { display: none; }
    </style>
</head>
<body class="dark bg-slate-900 text-gray-200 flex flex-col h-screen overflow-hidden">
    <div id="app" class="flex flex-col h-full" v-cloak>
        <div id="toolbar" class="p-2 m-1 sm:m-2 flex items-center space-x-1 flex-wrap bg-slate-800 border border-slate-700 rounded-lg shadow">
            <h2 class="text-md sm:text-lg font-semibold text-gray-100 px-1 sm:px-2 py-1 whitespace-nowrap">Sudoku</h2>
            <span class="border-r h-5 sm:h-6 border-slate-600 hidden xs:block"></span>
            
            <div class="relative">
                <button @click="toggleNewGameSubmenu" ref="newGameButton" title="New Game" class="tool-button bg-green-600 text-white hover:bg-green-500 active:bg-green-700 text-xs">
                    <i class="fas fa-plus mr-1"></i> New
                    <i class="fas fa-caret-down ml-1 sm:ml-2 transition-transform duration-200" :class="{'rotate-180': isNewGameSubmenuOpen}"></i>
                </button>
                <div v-if="isNewGameSubmenuOpen" 
                     id="newGameSubmenu" 
                     ref="newGameSubmenuElement"
                     class="absolute left-0 mt-1 w-32 sm:w-40 bg-slate-700 border border-slate-600 rounded-md shadow-lg py-1 z-50"> 
                    <a @click="selectDifficulty('easy')" class="submenu-item text-xs sm:text-sm">Easy</a>
                    <a @click="selectDifficulty('medium')" class="submenu-item text-xs sm:text-sm">Medium</a>
                    <a @click="selectDifficulty('hard')" class="submenu-item text-xs sm:text-sm">Hard</a>
                </div>
            </div>

            <button @click="checkPuzzle" title="Check Puzzle" class="tool-button bg-sky-600 text-white hover:bg-sky-500 active:bg-sky-700 text-xs">
                <i class="fas fa-check mr-1"></i> Check
            </button>
            <button @click="getHint" title="Get a Hint" class="tool-button bg-purple-600 text-white hover:bg-purple-500 active:bg-purple-700 text-xs">
                <i class="fas fa-magic mr-1"></i> Hint
            </button>
            <button @click="solvePuzzle" title="Solve Puzzle" class="tool-button bg-amber-500 text-black hover:bg-amber-400 active:bg-amber-600 text-xs">
                <i class="fas fa-lightbulb mr-1"></i> Solve
            </button>
             <button @click="resetPuzzle" title="Reset Puzzle" class="tool-button bg-red-600 text-white hover:bg-red-500 active:bg-red-700 text-xs">
                <i class="fas fa-undo mr-1"></i> Reset
            </button>
            <div class="flex-grow"></div>
            <button @click="isAboutModalOpen = true" title="Ã€ propos" class="tool-button icon-only bg-slate-600 text-gray-300 hover:bg-slate-500 active:bg-slate-700">
                <i class="fas fa-question-circle"></i>
            </button>
        </div>

        <div class="flex-grow m-1 sm:m-2 flex flex-col lg:flex-row items-center justify-center p-1 sm:p-2 rounded-lg custom-scrollbar"
             :style="{ backgroundColor: boardBgColor }">
            
            <div id="sudoku-grid" class="grid grid-cols-9 gap-px bg-slate-600 border border-slate-600 sm:border-2 sm:border-slate-500 rounded shadow-md sm:rounded-md sm:shadow-lg select-none w-full max-w-[calc(100vw-40px)] sm:max-w-md md:max-w-lg lg:max-w-xl">
                <template v-for="(row, r_idx) in sudokuGrid" :key="r_idx">
                    <div v-for="(cell, c_idx) in row" :key="`${r_idx}-${c_idx}`"
                         class="sudoku-cell aspect-square flex items-center justify-center cursor-pointer border border-slate-500 sm:border-slate-600"
                         :class="{
                            'bg-sky-700 ring-1 sm:ring-2 ring-sky-500 sm:ring-sky-400 z-10': isSelected(r_idx, c_idx),
                            'bg-red-800/30 hover:bg-red-700/50': !isSelected(r_idx, c_idx) && cell.isError,
                            'bg-sky-600/40': !isSelected(r_idx, c_idx) && !cell.isError && isSameNumber(r_idx, c_idx),
                            'bg-slate-600': !isSelected(r_idx, c_idx) && !cell.isError && !isSameNumber(r_idx, c_idx) && isRelated(r_idx, c_idx),
                            'bg-slate-800 hover:bg-slate-700/70': !isSelected(r_idx, c_idx) && !cell.isError && !isSameNumber(r_idx, c_idx) && !isRelated(r_idx, c_idx) && !cell.fixed,
                            'bg-slate-800/60': !isSelected(r_idx, c_idx) && !cell.isError && !isSameNumber(r_idx, c_idx) && !isRelated(r_idx, c_idx) && cell.fixed,
                             'border-r-slate-400 dark:border-r-slate-300': (c_idx + 1) % 3 === 0 && c_idx !== 8,
                             'border-b-slate-400 dark:border-b-slate-300': (r_idx + 1) % 3 === 0 && r_idx !== 8
                         }"
                         @click="selectCell(r_idx, c_idx)">
                        <span v-if="cell.currentValue !== 0"
                              :class="{
                                  'text-sky-300 font-bold': cell.fixed,
                                  'text-green-400': cell.currentValue !== 0 && !cell.fixed && !cell.isError && justChecked && gameWon,
                                  'text-red-400': cell.isError,
                                  'text-gray-200': !cell.fixed && !cell.isError && !(justChecked && gameWon)
                              }"
                              class="text-lg sm:text-xl md:text-2xl lg:text-3xl font-medium">
                            {{ cell.currentValue }}
                        </span>

                        <div v-else class="w-full h-full grid grid-cols-3 grid-rows-3 items-center justify-items-center p-px text-xs sm:text-xs md:text-sm font-light leading-none select-none">
                            <template v-for="candidateValue in [1,2,3,4,5,6,7,8,9]" :key="candidateValue">
                                <span :class="{
                                          'text-red-400': cell.candidates.red.includes(candidateValue),
                                          'text-green-400': cell.candidates.green.includes(candidateValue) && !cell.candidates.red.includes(candidateValue),
                                          'invisible': !cell.candidates.red.includes(candidateValue) && !cell.candidates.green.includes(candidateValue)
                                      }">
                                    {{ candidateValue }}
                                </span>
                            </template>
                        </div>
                    </div>
                </template>
            </div>

            <div class="flex flex-col items-center mt-4 lg:mt-0 lg:ml-8">
                <div id="number-pad" class="grid grid-cols-5 gap-1 sm:gap-1.5 md:gap-2">
                    <button v-for="num in [1,2,3,4,5,6,7,8,9]" :key="num"
                            @click="inputNumber(num)"
                            :class="['tool-button w-10 h-10 text-lg sm:w-12 sm:h-12 sm:text-xl md:w-14 md:h-14 md:text-2xl lg:w-16 lg:h-16 lg:text-3xl rounded-md', {
                                'bg-slate-500 text-slate-300 cursor-not-allowed opacity-75': numberCounts[num] === 9 && currentInputMode === 'normal',
                                'bg-sky-600 hover:bg-sky-500 text-white': !(numberCounts[num] === 9 && currentInputMode === 'normal')
                            }]"
                            :disabled="numberCounts[num] === 9 && currentInputMode === 'normal'">
                        {{num}}
                    </button>
                    <button @click="inputNumber(0)" title="Clear cell (Backspace/Delete/0)"
                            class="tool-button w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 lg:w-16 lg:h-16 bg-slate-600 hover:bg-slate-500 text-white rounded-md">
                        <i class="fas fa-backspace text-lg sm:text-xl md:text-2xl lg:text-3xl"></i>
                    </button>
                </div>
                 <div class="mt-3 sm:mt-4 flex justify-center space-x-2">
                    <button @click="currentInputMode = 'normal'"
                            aria-label="Normal input mode"
                            :class="['tool-button p-2 sm:p-2.5 text-sm sm:text-base rounded-md', currentInputMode === 'normal' ? 'bg-blue-600 text-white ring-2 ring-blue-400' : 'bg-slate-600 hover:bg-slate-500 text-gray-200']">
                        <i class="fas fa-pencil-alt" :class="currentInputMode === 'normal' ? 'text-white' : 'text-sky-400'"></i>
                    </button>
                    <button @click="currentInputMode = 'red'"
                            aria-label="Red candidate input mode"
                            :class="['tool-button p-2 sm:p-2.5 text-sm sm:text-base rounded-md', currentInputMode === 'red' ? 'bg-red-600 text-white ring-2 ring-red-400' : 'bg-slate-600 hover:bg-slate-500 text-gray-200']">
                        <i class="fas fa-pencil-alt" :class="currentInputMode === 'red' ? 'text-white' : 'text-red-400'"></i>
                    </button>
                    <button @click="currentInputMode = 'green'"
                            aria-label="Green candidate input mode"
                            :class="['tool-button p-2 sm:p-2.5 text-sm sm:text-base rounded-md', currentInputMode === 'green' ? 'bg-green-600 text-white ring-2 ring-green-400' : 'bg-slate-600 hover:bg-slate-500 text-gray-200']">
                        <i class="fas fa-pencil-alt" :class="currentInputMode === 'green' ? 'text-white' : 'text-green-400'"></i>
                    </button>
                </div>
            </div>
        </div>

        <modal :is-open="isMessageModalOpen" @close="isMessageModalOpen = false" :title="messageModalTitle">
            <p class="text-gray-300 mb-4" :class="messageModalTypeClass">{{ messageModalText }}</p>
            <div class="flex justify-end">
                <button @click="isMessageModalOpen = false" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">OK</button>
            </div>
        </modal>

        <modal :is-open="isAboutModalOpen" @close="isAboutModalOpen = false" title="About Sudoku Game" width-class="max-w-xs sm:max-w-sm md:max-w-md"> 
            <p class="text-gray-300 mb-2 text-sm sm:text-base"><strong>Version:</strong> 1.2.0 (LocalStorage Fixed)</p> 
            <p class="text-gray-300 mb-4 text-sm sm:text-base">A classic Sudoku puzzle game with dynamically generated puzzles and progress saving.</p>
            <p class="text-gray-300 mb-4 text-xs sm:text-sm">Select a cell and use the number pad or your keyboard (1-9 to input, 0/Backspace/Delete to clear, Arrow keys to navigate) to fill the grid. Use the pencil icons to switch to candidate input mode. Errors are shown after clicking 'Check'.</p>
            <div class="border-t border-slate-700 pt-3 sm:pt-4 mt-3 sm:mt-4">
                <h4 class="text-sm sm:text-md font-semibold mb-2 text-gray-200">Built with:</h4>
                <ul class="list-disc list-inside text-xs sm:text-sm text-gray-400">
                    <li>Vue.js 3</li><li>Tailwind CSS</li><li>Font Awesome</li>
                </ul>
            </div>
            <div class="flex justify-end mt-4 sm:mt-6">
                <button @click="isAboutModalOpen = false" class="px-3 py-1.5 sm:px-4 sm:py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors text-sm sm:text-base">Close</button>
            </div>
        </modal>

    </div>

    <script>
        const DEFAULT_BOARD_BG_COLOR = '#0d1117';

        const LCG_A_GEN = 1664525;
        const LCG_C_GEN = 1013904223;
        const LCG_M_GEN = Math.pow(2, 32);

        // Difficulty settings: Target number of clues (filled cells)
        // These are now dynamic within the generator for better seeding.
        // const difficultySettings = {
        //     easy: { clues: 36 + Math.floor(Math.random() * 5) }, // 36-40
        //     medium: { clues: 30 + Math.floor(Math.random() * 5) }, // 30-34
        //     hard: { clues: 24 + Math.floor(Math.random() * 4) }  // 24-27
        // };
        
        class SudokuGenerator {
            constructor() {
                this.numberList = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.solutionCount = 0;
            }

            // LCG seeded random number generator
            _seededRandom(seed) {
                const nextSeed = (LCG_A_GEN * seed + LCG_C_GEN) % LCG_M_GEN;
                return { randomNumber: nextSeed / LCG_M_GEN, nextSeed: nextSeed };
            }

            // Fisher-Yates shuffle using the seeded random number generator
            _shuffleArray(array, seedObj) { // seedObj is an object { currentSeed: value }
                let m = array.length, t, i;
                while (m) {
                    const { randomNumber, nextSeed } = this._seededRandom(seedObj.currentSeed);
                    seedObj.currentSeed = nextSeed; // Update the seed in the passed object
                    i = Math.floor(randomNumber * m--);
                    t = array[m];
                    array[m] = array[i];
                    array[i] = t;
                }
                return array;
            }
            
            _createEmptyGrid() {
                return Array(9).fill(null).map(() => Array(9).fill(0));
            }

            _isGridFull(grid) {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (grid[r][c] === 0) return false;
                    }
                }
                return true;
            }
            
            _isValidPlacement(grid, r, c, val) {
                // Check row
                for (let i = 0; i < 9; i++) {
                    if (grid[r][i] === val && i !== c) return false;
                }
                // Check column
                for (let i = 0; i < 9; i++) {
                    if (grid[i][c] === val && i !== r) return false;
                }
                // Check 3x3 subgrid
                const startRow = r - (r % 3);
                const startCol = c - (c % 3);
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[startRow + i][startCol + j] === val && (startRow + i !== r || startCol + j !== c)) return false;
                    }
                }
                return true;
            }
            
            _deepCopyGrid(grid) {
                return JSON.parse(JSON.stringify(grid));
            }

            generateSolvedGrid(seedObj) {
                let grid = this._createEmptyGrid();
                this._fillRecursive(grid, seedObj);
                return grid;
            }

            _fillRecursive(grid, seedObj) {
                for (let i = 0; i < 81; i++) {
                    const r = Math.floor(i / 9);
                    const c = i % 9;
                    if (grid[r][c] === 0) {
                        let localNumberList = [...this.numberList];
                        this._shuffleArray(localNumberList, seedObj); // Use the seeded shuffle
                        for (const val of localNumberList) {
                            if (this._isValidPlacement(grid, r, c, val)) {
                                grid[r][c] = val;
                                if (this._isGridFull(grid)) {
                                    return true; // Found a solution
                                }
                                if (this._fillRecursive(grid, seedObj)) {
                                    return true; // Propagate success upwards
                                }
                                grid[r][c] = 0; // Backtrack
                            }
                        }
                        return false; // No valid number found for this cell
                    }
                }
                return true; // Grid is filled (should be caught by _isGridFull earlier)
            }

            countSolutions(grid) {
                this.solutionCount = 0;
                this._countSolutionsRecursive(this._deepCopyGrid(grid));
                return this.solutionCount;
            }

            _countSolutionsRecursive(grid) {
                if (this.solutionCount > 1) return; // Optimization: stop if more than one solution found

                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (grid[r][c] === 0) { // Find an empty cell
                            for (let val = 1; val <= 9; val++) {
                                if (this.solutionCount > 1) return; // Check again inside the loop
                                if (this._isValidPlacement(grid, r, c, val)) {
                                    grid[r][c] = val;
                                    if (this._isGridFull(grid)) {
                                        this.solutionCount++;
                                    } else {
                                        this._countSolutionsRecursive(grid);
                                    }
                                    grid[r][c] = 0; // Backtrack
                                }
                            }
                            return; // Return after trying all numbers for the first empty cell
                        }
                    }
                }
                 // This part is reached if the grid is already full when called.
                 // If the initial call is on a full grid, it should be a solution.
                 // However, the primary path is _isGridFull inside the recursion.
            }

            createPuzzleFromSolution(solvedGrid, difficulty, seedObj) {
                let puzzle = this._deepCopyGrid(solvedGrid);
                let targetClues;
                
                // Re-evaluate targetClues with current seed for this specific puzzle generation attempt
                const { randomNumber: diffRand, nextSeed: s1 } = this._seededRandom(seedObj.currentSeed);
                seedObj.currentSeed = s1;

                if (difficulty === 'easy') targetClues = 36 + Math.floor(diffRand * 5); // 36-40
                else if (difficulty === 'medium') targetClues = 30 + Math.floor(diffRand * 5); // 30-34
                else if (difficulty === 'hard') targetClues = 24 + Math.floor(diffRand * 4);  // 24-27
                else targetClues = 32; // Default if difficulty string is unexpected

                let currentClues = 81;
                let cells = [];
                for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) cells.push({ r, c });
                this._shuffleArray(cells, seedObj); // Shuffle cells to try removing in random order

                for (const cell of cells) {
                    if (currentClues <= targetClues) break;
                    const { r, c } = cell;
                    if (puzzle[r][c] === 0) continue; // Already empty

                    const backup = puzzle[r][c];
                    puzzle[r][c] = 0; // Try removing the number
                    
                    // Check if the puzzle still has a unique solution
                    if (this.countSolutions(puzzle) !== 1) {
                        puzzle[r][c] = backup; // Restore if not unique or no solution
                    } else {
                        currentClues--;
                    }
                }
                return puzzle;
            }
        }


        const ModalComponent = {
            props: { isOpen: Boolean, title: String, widthClass: { type: String, default: 'max-w-sm' } }, // Added widthClass prop
            emits: ['close'],
            template: `
                <div v-if="isOpen" class="fixed inset-0 modal-backdrop flex items-center justify-center z-50 p-4" @click.self="$emit('close')">
                    <div class="modal-content p-4 sm:p-5 rounded-lg shadow-xl w-full" :class="widthClass" @click.stop"> 
                        <div class="flex justify-between items-center mb-3 sm:mb-4">
                            <h3 class="text-md sm:text-lg font-semibold text-white">{{ title }}</h3>
                            <button @click="$emit('close')" class="text-gray-500 hover:text-gray-300 transition-colors">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <slot></slot>
                    </div>
                </div>`
        };

        const app = Vue.createApp({
            components: { 'modal': ModalComponent },
            data() {
                return {
                    boardTitle: "Sudoku Game",
                    sudokuGrid: [], // Stores the visual grid: { currentValue, fixed, isError, candidates }
                    selectedCell: { r: -1, c: -1 },
                    currentPuzzleDefinition: null, // Stores the initial puzzle numbers (0 for empty)
                    currentSolutionDefinition: null, // Stores the solved puzzle numbers
                    currentDifficulty: 'easy',
                    currentSeed: Date.now(), // Seed for puzzle generation
                    sudokuGenerator: new SudokuGenerator(), // Instantiate the generator
                    boardBgColor: DEFAULT_BOARD_BG_COLOR,
                    isAboutModalOpen: false,
                    isNewGameSubmenuOpen: false, 
                    isMessageModalOpen: false,
                    messageModalTitle: '',
                    messageModalText: '',
                    messageModalType: 'info', // 'info', 'success', 'error'
                    gameWon: false,
                    justChecked: false, // Flag to indicate if checkPuzzle was just run
                    numberCounts: {}, // Counts of each number on the board
                    currentInputMode: 'normal', // 'normal', 'red', 'green' for candidates
                }
            },
            computed: {
                selectedCellValue() {
                    if (this.selectedCell.r === -1) return 0;
                    if (!this.sudokuGrid || !this.sudokuGrid[this.selectedCell.r] || !this.sudokuGrid[this.selectedCell.r][this.selectedCell.c]) return 0;
                    return this.sudokuGrid[this.selectedCell.r][this.selectedCell.c].currentValue;
                },
                messageModalTypeClass() {
                    if (this.messageModalType === 'success') return 'text-green-400';
                    if (this.messageModalType === 'error') return 'text-red-400';
                    return 'text-sky-400'; // Default for 'info'
                }
            },
            methods: {
                toggleNewGameSubmenu() {
                    this.isNewGameSubmenuOpen = !this.isNewGameSubmenuOpen;
                },
                selectDifficulty(difficulty) {
                    this.startNewGame(difficulty); 
                    this.isNewGameSubmenuOpen = false; 
                },
                startNewGame(difficulty) {
                    this.currentInputMode = 'normal';
                    this.numberCounts = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0}; // Reset counts
                    this.gameWon = false;
                    this.justChecked = false;
                    this.currentDifficulty = difficulty;

                    // Use a seed object that can be passed by reference to be updated by generator methods
                    let seedObj = { currentSeed: this.currentSeed }; 
                    
                    this.currentSolutionDefinition = this.sudokuGenerator.generateSolvedGrid(seedObj);
                    this.currentPuzzleDefinition = this.sudokuGenerator.createPuzzleFromSolution(
                        this.currentSolutionDefinition, 
                        difficulty, 
                        seedObj 
                    );
                    
                    // Update number counts based on the new puzzle
                    if (this.currentPuzzleDefinition) {
                        for (let r = 0; r < 9; r++) {
                            for (let c = 0; c < 9; c++) {
                                const val = this.currentPuzzleDefinition[r][c];
                                if (val >= 1 && val <= 9) {
                                    this.numberCounts[val]++;
                                }
                            }
                        }
                    }
                    
                    this.currentSeed = seedObj.currentSeed; // Persist the updated seed for the next game generation
                    
                    this.loadPuzzle(); // Initialize sudokuGrid from currentPuzzleDefinition
                    this.selectedCell = { r: -1, c: -1 }; // Reset selection
                    this.saveGameToLocalStorage(); // Save the new game state
                },
                loadPuzzle() {
                    // This function initializes the visual `sudokuGrid` based on `currentPuzzleDefinition`.
                    // It's called when a new game starts or when loading a game (before merging user inputs).
                    if (!this.currentPuzzleDefinition) return;
                    this.sudokuGrid = this.currentPuzzleDefinition.map(row => 
                        row.map(val => ({
                            currentValue: val,
                            fixed: val !== 0,
                            isError: false,
                            candidates: { red: [], green: [] } // Initialize empty candidates
                        }))
                    );
                },
                selectCell(r, c) {
                    this.selectedCell = { r, c };
                },
                isSelected(r, c) {
                    return this.selectedCell.r === r && this.selectedCell.c === c;
                },
                isRelated(r, c) {
                    if (this.selectedCell.r === -1) return false;
                    if (this.isSelected(r,c)) return false; // Don't highlight the selected cell itself as "related"
                    const selectedR = this.selectedCell.r;
                    const selectedC = this.selectedCell.c;
                    // Check row and column
                    if (r === selectedR || c === selectedC) return true;
                    // Check 3x3 box
                    const boxStartR = Math.floor(selectedR / 3) * 3;
                    const boxStartC = Math.floor(selectedC / 3) * 3;
                    if (r >= boxStartR && r < boxStartR + 3 && c >= boxStartC && c < boxStartC + 3) return true;
                    return false;
                },
                isSameNumber(r, c) {
                    if (this.selectedCellValue === 0) return false;
                    if (this.isSelected(r, c)) return false;
                    return this.sudokuGrid[r][c].currentValue === this.selectedCellValue;
                },
                inputNumber(num) {
                    if (this.selectedCell.r === -1 || this.gameWon) return; // No cell selected or game won
                    const { r, c } = this.selectedCell;
                    const cell = this.sudokuGrid[r][c];

                    if (cell.fixed) return; // Cannot change fixed cells

                    if (this.currentInputMode === 'normal') {
                        const oldValue = cell.currentValue;

                        // Decrement count for the old number if it was a valid number
                        if (oldValue >= 1 && oldValue <= 9) {
                            if (this.numberCounts[oldValue] > 0) this.numberCounts[oldValue]--;
                        }

                        cell.currentValue = num; // Set new number (0 for clear)
                        cell.isError = false; // Reset error state on input

                        // Increment count for the new number if it's a valid number
                        if (num >= 1 && num <= 9) {
                            this.numberCounts[num]++;
                        }
                        
                        // If a normal number is placed (not cleared), clear candidates
                        if (num !== 0) {
                            cell.candidates.red = [];
                            cell.candidates.green = [];
                        }

                    } else if (this.currentInputMode === 'red' || this.currentInputMode === 'green') {
                        const color = this.currentInputMode; // 'red' or 'green'

                        if (num >= 1 && num <= 9) { // Toggle candidate
                            if (cell.currentValue !== 0) return; // Candidates only if cell is empty

                            const candidatesArray = cell.candidates[color];
                            const index = candidatesArray.indexOf(num);
                            if (index > -1) { // Already a candidate, remove it
                                candidatesArray.splice(index, 1);
                            } else { // Not a candidate, add it
                                candidatesArray.push(num);
                                candidatesArray.sort((a, b) => a - b); // Keep them sorted for display
                            }
                        } else if (num === 0) { // Clear all candidates of this color
                            cell.candidates[color] = [];
                        }
                        // cell.isError = false; // Optionally reset error state for candidate changes
                    }
                    this.saveGameToLocalStorage();
                },
                clearAllErrors() {
                    for (let i = 0; i < 9; i++) {
                        for (let j = 0; j < 9; j++) {
                            if (this.sudokuGrid[i] && this.sudokuGrid[i][j]) { // Ensure cell exists
                                 this.sudokuGrid[i][j].isError = false;
                            }
                        }
                    }
                },
                getHint() {
                    if (this.gameWon) return;

                    let r = this.selectedCell.r;
                    let c = this.selectedCell.c;
                    let cell = null;

                    // First try selected cell if it's not correct
                    if (r !== -1 && c !== -1) {
                        let current = this.sudokuGrid[r][c];
                        if (!current.fixed) {
                             let correctVal = this.currentSolutionDefinition[r][c];
                             if (current.currentValue !== correctVal) {
                                 cell = current;
                             }
                        }
                    }

                    // If selected cell didn't need a hint (was correct or fixed), find another one
                    if (!cell) {
                        let candidates = [];
                        for(let i=0; i<9; i++) {
                            for(let j=0; j<9; j++) {
                                let gCell = this.sudokuGrid[i][j];
                                if (!gCell.fixed) {
                                    let correctVal = this.currentSolutionDefinition[i][j];
                                    if (gCell.currentValue !== correctVal) {
                                        candidates.push({r:i, c:j});
                                    }
                                }
                            }
                        }
                        if (candidates.length === 0) {
                             this.showMessage("Info", "The puzzle appears to be solved!", "success");
                             return;
                        }
                        // Pick random
                        let randIndex = Math.floor(Math.random() * candidates.length);
                        let coords = candidates[randIndex];
                        cell = this.sudokuGrid[coords.r][coords.c];

                        // Select this cell to show the user where the hint happened
                        this.selectCell(coords.r, coords.c);
                    }

                    // Apply hint
                    if (cell) {
                        // Decrement count of old value if valid
                        if (cell.currentValue >= 1 && cell.currentValue <= 9) {
                             if (this.numberCounts[cell.currentValue] > 0) this.numberCounts[cell.currentValue]--;
                        }

                        let newVal = this.currentSolutionDefinition[this.selectedCell.r][this.selectedCell.c];
                        cell.currentValue = newVal;
                        cell.fixed = true;
                        cell.isError = false;
                        cell.candidates.red = [];
                        cell.candidates.green = [];

                        this.numberCounts[newVal]++;
                        this.saveGameToLocalStorage();
                    }
                },
                checkPuzzle() {
                    if (this.gameWon) {
                        this.showMessage("Game Over", "You've already solved this puzzle!", "info");
                        return;
                    }
                    // Create a simple numeric grid for validation logic
                    const numericGrid = this.sudokuGrid.map(row => 
                        row.map(cell => cell.currentValue)
                    );
                    this.clearAllErrors(); 
                    let hasRuleViolations = false;
                    let isFull = true;
                    let allCorrectAccordingToSolution = true;

                    for (let r_idx = 0; r_idx < 9; r_idx++) {
                        for (let c_idx = 0; c_idx < 9; c_idx++) {
                            const cell = this.sudokuGrid[r_idx][c_idx];
                            if (cell.currentValue === 0) {
                                isFull = false; // Puzzle is not full
                            } else { 
                                // Check for basic Sudoku rule violations
                                if (!this.sudokuGenerator._isValidPlacement(numericGrid, r_idx, c_idx, cell.currentValue)) {
                                    cell.isError = true; 
                                    hasRuleViolations = true;
                                }
                                // Check against the known solution
                                if (this.currentSolutionDefinition && cell.currentValue !== this.currentSolutionDefinition[r_idx][c_idx]) {
                                    allCorrectAccordingToSolution = false;
                                    // Do not mark as error here solely based on mismatch with solution,
                                    // only if it violates Sudoku rules (handled above) or if user is checking a full board.
                                }
                            }
                        }
                    }
                    this.justChecked = true; // Indicate that a check has been performed

                    if (hasRuleViolations) {
                        this.showMessage("Check Results", "There are some rule violations in your solution. Keep trying!", "error");
                        this.gameWon = false; 
                    } else if (!isFull) {
                        this.showMessage("Check Results", "No rule violations found so far, but the puzzle is not complete yet.", "info");
                        this.gameWon = false;
                    } else { // Grid is full and no basic rule violations
                        if(allCorrectAccordingToSolution){
                            this.showMessage("Congratulations!", "You've solved the Sudoku puzzle correctly!", "success");
                            this.gameWon = true;
                        } else {
                            // If full, no rule violations, but not matching the solution, then mark errors based on solution.
                            for (let r_idx = 0; r_idx < 9; r_idx++) {
                                for (let c_idx = 0; c_idx < 9; c_idx++) {
                                     if (this.sudokuGrid[r_idx][c_idx].currentValue !== this.currentSolutionDefinition[r_idx][c_idx]) {
                                        this.sudokuGrid[r_idx][c_idx].isError = true;
                                    }
                                }
                            }
                            this.showMessage("Check Results", "The puzzle is complete, but some numbers are incorrect.", "error");
                            this.gameWon = false;
                        }
                    }
                    this.saveGameToLocalStorage(); // Save state after check
                },
                solvePuzzle() {
                    if (!this.currentSolutionDefinition) {
                        this.showMessage("Error", "No solution available for this puzzle.", "error");
                        return;
                    }
                    this.numberCounts = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0}; // Reset counts
                     if (this.currentSolutionDefinition) {
                        for (let r = 0; r < 9; r++) {
                            for (let c = 0; c < 9; c++) {
                                const val = this.currentSolutionDefinition[r][c];
                                if (val >= 1 && val <= 9) {
                                    this.numberCounts[val]++;
                                }
                            }
                        }
                    }

                    this.clearAllErrors(); 
                    // Rebuild the grid based on the solution, preserving fixed status from original puzzle
                    this.sudokuGrid = this.currentSolutionDefinition.map((row, r_idx) => 
                        row.map((val, c_idx) => ({
                            currentValue: val,
                            fixed: this.currentPuzzleDefinition[r_idx][c_idx] !== 0, // Fixed if it was part of the initial puzzle
                            isError: false,
                            candidates: { red: [], green: [] } // Clear candidates
                        }))
                    );
                    
                    this.gameWon = true; 
                    this.justChecked = true; // To trigger any win styling
                    this.selectedCell = {r: -1, c: -1}; // Deselect cell
                    this.showMessage("Solved", "The puzzle has been solved for you.", "info");
                    this.saveGameToLocalStorage();
                },
                resetPuzzle() {
                    if (!this.currentPuzzleDefinition) return; // Can't reset if there's no puzzle

                    this.loadPuzzle(); // Resets the grid from the original puzzle definition

                    // Recalculate number counts from the original puzzle
                    this.numberCounts = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0};
                    for (let r = 0; r < 9; r++) {
                        for (let c = 0; c < 9; c++) {
                            const val = this.currentPuzzleDefinition[r][c];
                            if (val >= 1 && val <= 9) {
                                this.numberCounts[val]++;
                            }
                        }
                    }

                    // Reset game state
                    this.gameWon = false;
                    this.justChecked = false;
                    this.clearAllErrors();
                    this.selectedCell = { r: -1, c: -1 };
                    this.currentInputMode = 'normal';

                    this.saveGameToLocalStorage(); // Save the clean state
                    this.showMessage("Puzzle Reset", "The board has been returned to its initial state.", "info");
                },
                showMessage(title, text, type = 'info') {
                    this.messageModalTitle = title;
                    this.messageModalText = text;
                    this.messageModalType = type;
                    this.isMessageModalOpen = true;
                },
                handleGlobalClick(event) {
                    // Close new game submenu if clicked outside
                    const newGameSubmenuEl = this.$refs.newGameSubmenuElement;
                    const newGameButtonEl = this.$refs.newGameButton;
                    if (this.isNewGameSubmenuOpen && newGameSubmenuEl && !newGameSubmenuEl.contains(event.target) &&
                        newGameButtonEl && !newGameButtonEl.contains(event.target)) { // Check button too
                        this.isNewGameSubmenuOpen = false;
                    }
                },
                handleGlobalKeyDown(e) {
                    if (e.key === 'Escape') {
                        if (this.isMessageModalOpen) this.isMessageModalOpen = false;
                        else if (this.isAboutModalOpen) this.isAboutModalOpen = false;
                        else if (this.isNewGameSubmenuOpen) this.isNewGameSubmenuOpen = false;
                        else if (this.selectedCell.r !== -1 || this.selectedCell.c !== -1) { 
                           this.selectedCell = { r: -1, c: -1 }; // Deselect cell
                        }
                        return; 
                    }
                    // Keyboard input for numbers and navigation
                    if (!this.isMessageModalOpen && !this.isAboutModalOpen && !this.isNewGameSubmenuOpen) {
                        if (this.selectedCell.r !== -1 && !this.gameWon) { // Cell selected and game not won
                            if (e.key >= '1' && e.key <= '9') {
                                this.inputNumber(parseInt(e.key));
                                e.preventDefault();
                            } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') { // Treat '0' as clear
                                this.inputNumber(0); // Clear cell
                                e.preventDefault();
                            } else if (e.key.startsWith('Arrow')) {
                                e.preventDefault();
                                let { r, c } = this.selectedCell;
                                if (e.key === 'ArrowUp' && r > 0) r--;
                                else if (e.key === 'ArrowDown' && r < 8) r++;
                                else if (e.key === 'ArrowLeft' && c > 0) c--;
                                else if (e.key === 'ArrowRight' && c < 8) c++;
                                this.selectCell(r, c);
                            }
                        }
                    }
                },
                saveGameToLocalStorage() {
                    // console.log("Attempting to save game...");
                    try {
                        if (!this.currentPuzzleDefinition) {
                            // console.warn('Skipping save: currentPuzzleDefinition is missing.');
                            return;
                        }
                        const gameState = {
                            sudokuGrid: this.sudokuGrid, // The current visual grid with user inputs
                            currentPuzzleDefinition: this.currentPuzzleDefinition,
                            currentSolutionDefinition: this.currentSolutionDefinition,
                            currentDifficulty: this.currentDifficulty,
                            numberCounts: this.numberCounts,
                            gameWon: this.gameWon,
                            selectedCell: this.selectedCell,
                            currentSeed: this.currentSeed // Save the seed too, for consistency if needed
                        };
                        localStorage.setItem('sudokuGameState', JSON.stringify(gameState));
                        // console.log('Game state saved:', gameState);
                    } catch (error) {
                        console.error('Error saving game to localStorage:', error);
                        // Potentially notify user or offer to clear storage if it's full
                    }
                },
                loadGameFromLocalStorage() {
                    // console.log("Attempting to load game...");
                    const savedStateJSON = localStorage.getItem('sudokuGameState');
                    if (!savedStateJSON) {
                        // console.log('No saved game state found in localStorage.');
                        return false; // Indicate that loading failed, so a new game should start
                    }

                    try {
                        const loadedState = JSON.parse(savedStateJSON);
                        // console.log('Successfully parsed loadedState:', loadedState);

                        if (!loadedState || typeof loadedState !== 'object') {
                            console.error('Invalid saved state format. Removing from localStorage.');
                            localStorage.removeItem('sudokuGameState');
                            return false;
                        }

                        // Validate essential data
                        if (!loadedState.currentPuzzleDefinition || !loadedState.sudokuGrid || !loadedState.numberCounts) {
                             console.error('Essential game data missing in saved state. Removing from localStorage. currentPuzzleDefinition:', loadedState.currentPuzzleDefinition, 'sudokuGrid:', loadedState.sudokuGrid, 'numberCounts:', loadedState.numberCounts);
                             localStorage.removeItem('sudokuGameState');
                             return false;
                        }

                        // Restore core puzzle definitions and difficulty
                        this.currentPuzzleDefinition = loadedState.currentPuzzleDefinition;
                        this.currentSolutionDefinition = loadedState.currentSolutionDefinition; // Might be null if saved from an older version
                        this.currentDifficulty = loadedState.currentDifficulty || 'easy';
                        this.currentSeed = loadedState.currentSeed || Date.now(); // Restore seed

                        // Initialize this.sudokuGrid based on the loaded currentPuzzleDefinition.
                        // This ensures `fixed` properties are correctly set.
                        this.loadPuzzle(); 

                        // Now, merge the user's progress from loadedState.sudokuGrid into the newly initialized this.sudokuGrid
                        // This step is crucial for restoring user-entered numbers, candidates, and error states.
                        if (loadedState.sudokuGrid && this.sudokuGrid && this.sudokuGrid.length === 9) {
                            // console.log('Merging user progress from loadedState.sudokuGrid into the initialized this.sudokuGrid');
                            for (let r = 0; r < 9; r++) {
                                for (let c = 0; c < 9; c++) {
                                    // Ensure both source and target cells exist
                                    if (this.sudokuGrid[r] && this.sudokuGrid[r][c] && loadedState.sudokuGrid[r] && loadedState.sudokuGrid[r][c]) {
                                        const savedCell = loadedState.sudokuGrid[r][c];
                                        const currentCell = this.sudokuGrid[r][c];

                                        // Only update currentValue and candidates for non-fixed cells
                                        if (!currentCell.fixed) {
                                            currentCell.currentValue = savedCell.currentValue;
                                            // Ensure candidates object and its arrays exist before assigning
                                            currentCell.candidates = {
                                                red: Array.isArray(savedCell.candidates?.red) ? savedCell.candidates.red : [],
                                                green: Array.isArray(savedCell.candidates?.green) ? savedCell.candidates.green : []
                                            };
                                        }
                                        // Restore error state for all cells (fixed or not)
                                        currentCell.isError = savedCell.isError || false;
                                    }
                                }
                            }
                        } else {
                            console.warn('Could not merge user progress: this.sudokuGrid or loadedState.sudokuGrid is not as expected after loadPuzzle().');
                        }

                        // Restore other game state properties
                        this.numberCounts = loadedState.numberCounts;
                        this.gameWon = loadedState.gameWon || false;
                        this.selectedCell = loadedState.selectedCell || { r: -1, c: -1 };
                        
                        // console.log('Full game state restored.');
                        return true; // Indicate successful load

                    } catch (error) {
                        console.error('Error loading game from localStorage:', error);
                        localStorage.removeItem('sudokuGameState'); // Clear corrupted data
                        return false; // Indicate that loading failed
                    }
                }
            },
            mounted() {
                // Attempt to load the game. If it fails (returns false), start a new one.
                if (!this.loadGameFromLocalStorage()) {
                    this.startNewGame(this.currentDifficulty || 'easy');
                }
                document.addEventListener('click', this.handleGlobalClick, true); // Use capture phase for wider coverage
                document.addEventListener('keydown', this.handleGlobalKeyDown);
            },
            beforeUnmount() {
                document.removeEventListener('click', this.handleGlobalClick, true);
                document.removeEventListener('keydown', this.handleGlobalKeyDown);
            }
        });
        app.mount('#app');
    </script>
</body>
</html>
